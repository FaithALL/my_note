## x86-64 ATT汇编

[基础知识](#基础知识)

[处理器状态](#处理器状态)

[汇编语法](#汇编语法)

### 基础知识

* 指令集体系结构或指令集架构(ISA)定义了处理器状态、指令的格式以及每条指令对状态的影响。
* 对CPU而言，系统中所有存储器中的存储单元都在一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。
* 三类总线：地址总线、数据总线、控制总线。
* 大小端：低位字节在低地址为小端、低位字节在高地址为大端。
* 一般而言，有符号数采用算术右移补符号位，无符号数采用逻辑右移补0。
* 数的表示和处理
  * 无符号整数直接编码，有符号数采用补码，补码最高有效位被解释为负权。
  * 有符号整数和无符号整数的加法、乘法计算方法相同。[w位补码乘法要符号扩展到2w位后再运算](https://www.zhihu.com/question/22420697)。
  * 浮点数的表示：符号位+阶码+尾数
  

### 处理器状态

* 程序计数器：`%rip`，存下一条指令的内存地址
* 整数寄存器：16个64位通用寄存器，存储地址和或数据。
* 条件码寄存器：存算术或逻辑指令的状态信息。
* 一组向量寄存器：存一个或多个整数或浮点数。

### 汇编语法

* 数据格式

  | Intel数据类型 | 汇编代码后缀 | 大小(字节) |
  | ------------- | ------------ | ---------- |
  | 字节          | b            | 1          |
  | 字            | w            | 2          |
  | 双字          | l            | 4          |
  | 四字          | q            | 8          |
  | 单精度        | s            | 4          |
  | 双精度        | q            | 8          |

  > "四字"和"双精度"汇编后缀不会产生冲突，因为浮点数使用一组完全不同的指令和寄存器。

* 通用目的寄存器

  | 63~0   | 31~0    | 15~0    | 7~0     | 用途         |
  | ------ | ------- | ------- | ------- | ------------ |
  | `%rax` | `%eax`  | `%ax`   | `%al`   | 返回值       |
  | `%rbx` | `%ebx`  | `%bx`   | `%bl`   | 被调用者     |
  | `%rcx` | `%ecx`  | `%cx`   | `%cl`   | 第4个参数    |
  | `%rdx` | `%edx`  | `%dx`   | `%dl`   | 第3个参数    |
  | `%rsi` | `%esi`  | `%si`   | `%sil`  | 第2个参数    |
  | `%rdi` | `%edi`  | `%di`   | `%dil`  | 第1个参数    |
  | `%rbp` | `%ebp`  | `%bp`   | `%bpl`  | 被调用者保存 |
  | `%rsp` | `%esp`  | `%sp`   | `%spl`  | 栈指针       |
  | `%r8`  | `%r8d`  | `%r8w`  | `%r8b`  | 第5个参数    |
  | `%r9`  | `%r9d`  | `%r9w`  | `%r9b`  | 第6个参数    |
  | `%r10` | `%r10d` | `%r10w` | `%r10b` | 调用者保存   |
  | `%r11` | `%r11d` | `%r11w` | `%r11b` | 被调用者保存 |
  | `%r12` | `%r12d` | `%r12w` | `%r12b` | 被调用者保存 |
  | `%r13` | `%r13d` | `%r13w` | `%r13b` | 被调用者保存 |
  | `%r14` | `%r14d` | `%r14w` | `%r14b` | 被调用者保存 |
  | `%r15` | `%r15d` | `%r15w` | `%r15b` | 被调用者保存 |

  > 生成1字节和2字节数字的指令会保持剩下的字节不变；生成4字节数字的指令会把高位4字节置0。
  
* 操作数格式

  | 类型   | 格式             | 操作数值                 | 名称              |
  | ------ | ---------------- | ------------------------ | ----------------- |
  | 立即数 | $\$Imm$          | $Imm$                    | 立即数寻址        |
  | 寄存器 | $r_a$            | $R[r_a]$                 | 寄存器寻址        |
  | 存储器 | $Imm$            | $M[Imm]$                 | 绝对寻址          |
  | 存储器 | $(r_a)$          | $M[R[r_a]]$              | 间接寻址          |
  | 存储器 | $Imm(r_b)$       | $M[Imm+R[r_b]]$          | (基址+偏移量)寻址 |
  | 存储器 | $(r_b,r_i)$      | $M[R[r_b]+R[r_i]]$       | 变址寻址          |
  | 存储器 | $Imm(r_b,r_i)$   | $M[Imm+R[r_b]+R[r_i]]$   | 变址寻址          |
  | 存储器 | $(,r_i,s)$       | $M[R[r_i]*s]$            | 比例变址寻址      |
  | 存储器 | $Imm(,r_i,s)$    | $M[Imm+R[r_i]*s]$        | 比例变址寻址      |
  | 存储器 | $(r_b,r_i,s)$    | $M[R[r_b]+R[r_i]*s]$     | 比例变址寻址      |
  | 存储器 | $Imm(r_b,r_i,s)$ | $M[Imm+R[r_b]+R[r_i]*s]$ | 比例变址寻址      |

  * 立即数：$后跟一个用标准C表示的整数，不同指令允许的立即数范围不同。
  
  * 寄存器：$r_a$表示任意寄存器，用$R[r_a]$表示它的值。
  * 内存引用：$M_b[Addr]$表示内存中从$Addr$开始的b个字节的引用，通常省去下标b。
  * 基址寄存器$r_b$和变址寄存器$r_i$都必须是64位寄存器，s必须是1、2、4或者8。
  
* 数据传送指令

  | 指令(类)          | 效果                                                        | 描述           | 具体指令                                                   | 源操作数             | 目的操作数   |
  | ----------------- | ----------------------------------------------------------- | -------------- | ---------------------------------------------------------- | -------------------- | ------------ |
  | $MOV\quad S,\ D$  | $D\leftarrow S$                                             | 传送           | `movb`、`movw`、`movl`、`movq`、`movabsq`                  | 立即数、寄存器、内存 | 寄存器、内存 |
  | $MOVZ\quad S,\ R$ | $R\leftarrow 零扩展(S)$                                     | 以零扩展传送   | `movzbw`、`movzbl`、`movzwl`、`movzbq`、`movzwq`           | 寄存器、内存         | 寄存器       |
  | $MOVS\quad S,\ R$ | $R\leftarrow 符号扩展(S)$                                   | 以符号扩展传送 | `movsbw`、`movsbl`、`movswl`、`movsbq`、`movswq`、`movslq` | 寄存器、内存         | 寄存器       |
  | $cltq$            | $\%rax\leftarrow  符号扩展(\%eax)$                          | 以符号扩展传送 | 指令                                                       | 寄存器`%eax`         | 寄存器`%rax` |
  | $pushq\quad S$    | $R[\%rsp]\leftarrow R[\%rsp] - 8$ $M[R[\%rsp]]\leftarrow S$ | 将四字压栈     | 指令                                                       |                      |              |
  | $poq\quad D$      | $D\leftarrow M[R[\%rsp]]$ $R[\%rsp]\leftarrow R[\%rsp] + 8$ | 将四字弹出栈   | 指令                                                       |                      |              |

  * MOV类指令不能内存到内存传送。
  * `movl`指令以寄存器为目的时，会把目的寄存器高4字节置0，参见“通用目的寄存器”描述。因此没有`movzlq`指令。
  * 源操作数为立即数时，`movq`要求其必须能表示为32位补码，然后将之符号扩展到64位后传送。`movabsq`指令能够以任意64位立即数作为源操作数，并且只能以寄存器作为目的。

* 算术逻辑操作

  | 指令(类)          | 效果                                                         | 描述         |
  | ----------------- | ------------------------------------------------------------ | ------------ |
  | $leaq\quad S,\ D$ | $D\leftarrow \&S$                                            | 加载有效地址 |
  | $INC\quad D$      | $D\leftarrow D+1$                                            | 加1          |
  | $DEC\quad D$      | $D\leftarrow D-1$                                            | 减1          |
  | $NEG\quad D$      | $D\leftarrow -D$                                             | 取负         |
  | $NOT\quad D$      | $D\leftarrow \sim D$                                         | 取补         |
  | $ADD\quad S,\ D$  | $D\leftarrow D+S$                                            | 加           |
  | $SUB\quad S,\ D$  | $D\leftarrow D-S$                                            | 减           |
  | $IMUL\quad S,\ D$ | $D\leftarrow D*S$                                            | 乘           |
  | $XOR\quad S,\ D$  | $D\leftarrow D\verb!^! S$                                    | 异或         |
  | $OR\quad S,\ D$   | $D\leftarrow D|S$                                            | 或           |
  | $AND\quad S,\ D$  | $D\leftarrow D\&S$                                           | 与           |
  | $SAL\quad k,\ D$  | $D\leftarrow D<<k$                                           | 左移         |
  | $SHL\quad k,\ D$  | $D\leftarrow D<<k$                                           | 左移(同SAL)  |
  | $SAR\quad k,\ D$  | $D\leftarrow D>>_Ak$                                         | 算术右移     |
  | $SHR\quad k,\ D$  | $D\leftarrow D<<_Lk$                                         | 逻辑右移     |
  | $imulq\quad S$    | $R[\%rdx]:R[\%rax]\leftarrow S*R[\%rax]$                     | 有符号全乘法 |
  | $mulq\quad S$     | $R[\%rdx]:R[\%rax]\leftarrow S*R[\%rax]$                     | 无符号全乘法 |
  | $cqto$            | $R[\%rdx]:R[\%rax]\leftarrow 符号扩展(R[\%rax])$             | 转换为八字   |
  | $idivq\quad S$    | $R[\%rdx]\leftarrow R[\%rdx]:R[\%rax]\ mod\ S$ <br>$R[\%rdx]\leftarrow R[\%rdx]:R[\%rax]\div S$ | 有符号除法   |
  | $divq\quad S$     | $R[\%rdx]\leftarrow R[\%rdx]:R[\%rax]\ mod\ S$ <br/>$R[\%rdx]\leftarrow R[\%rdx]:R[\%rax]\div S$ | 无符号触发   |
  
  * 大写是指令类，包含四种不同大小数据的变种，例如ADD由四条指令组成`addb`、`addw`、`addl`、`addq`。小写是具体指令，没有变种。
  * `leaq`指令将有效地址写入目的寄存器。
  * 一元操作的操作数既可以是内存也可以是寄存器，二元操作的第一个操作数可以是立即数、寄存器或内存，第二个操作是寄存器或者内存。
  * 移位操作`k`可以是立即数或者寄存器`%cl`，第二个操作数可以是寄存器或者内存位置。
  * `imulq`有两种形式，一种属于`IMUL`指令类，双操作数，提供$64位*64位\rightarrow64位$的整数乘法。另一种属于上面单列的`imulq`指令，单操作数，提供$64位*64位\rightarrow128位$的整数乘法。因为乘积截断时，无符号乘和补码乘的位级表示一致，所以`IMUL`的`imulq`指令只有一条，而没有`mulq`。
  * Intel文档中`cqto`叫做`cqo`
