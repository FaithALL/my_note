## x86-64 ATT汇编

[基础知识](#基础知识)

[处理器状态](#处理器状态)

[汇编语法](#汇编语法)

### 基础知识

* 指令集体系结构或指令集架构(ISA)定义了处理器状态、指令的格式以及每条指令对状态的影响。
* 对CPU而言，系统中所有存储器中的存储单元都在一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。
* 三类总线：地址总线、数据总线、控制总线。
* 大小端：低位字节在低地址为小端、低位字节在高地址为大端。
* 一般而言，有符号数采用算术右移补符号位，无符号数采用逻辑右移补0。
* 数的表示和处理
  * 无符号整数直接编码，有符号数采用补码，补码最高有效位被解释为负权。
  * 有符号整数和无符号整数的加法、乘法计算方法相同。[w位补码乘法要符号扩展到2w位后再运算](https://www.zhihu.com/question/22420697)。
  * 浮点数的表示：符号位+阶码+尾数
  

### 处理器状态

* 程序计数器：`%rip`，存下一条指令的内存地址
* 整数寄存器：16个64位通用寄存器，存储地址和或数据。
* 条件码寄存器：一组单个位的条件码寄存器，存算术或逻辑指令的状态信息。
* 一组向量寄存器：存一个或多个整数或浮点数。

### 汇编语法

* 数据格式

  | Intel数据类型 | 汇编代码后缀 | 大小(字节) |
  | ------------- | ------------ | ---------- |
  | 字节          | b            | 1          |
  | 字            | w            | 2          |
  | 双字          | l            | 4          |
  | 四字          | q            | 8          |
  | 单精度        | s            | 4          |
  | 双精度        | q            | 8          |

  > "四字"和"双精度"汇编后缀不会产生冲突，因为浮点数使用一组完全不同的指令和寄存器。

* 整数寄存器

  | 63~0   | 31~0    | 15~0    | 7~0     | 用途         |
  | ------ | ------- | ------- | ------- | ------------ |
  | `%rax` | `%eax`  | `%ax`   | `%al`   | 返回值       |
  | `%rbx` | `%ebx`  | `%bx`   | `%bl`   | 被调用者保存 |
  | `%rcx` | `%ecx`  | `%cx`   | `%cl`   | 第4个参数    |
  | `%rdx` | `%edx`  | `%dx`   | `%dl`   | 第3个参数    |
  | `%rsi` | `%esi`  | `%si`   | `%sil`  | 第2个参数    |
  | `%rdi` | `%edi`  | `%di`   | `%dil`  | 第1个参数    |
  | `%rbp` | `%ebp`  | `%bp`   | `%bpl`  | 被调用者保存 |
  | `%rsp` | `%esp`  | `%sp`   | `%spl`  | 栈指针       |
  | `%r8`  | `%r8d`  | `%r8w`  | `%r8b`  | 第5个参数    |
  | `%r9`  | `%r9d`  | `%r9w`  | `%r9b`  | 第6个参数    |
  | `%r10` | `%r10d` | `%r10w` | `%r10b` | 调用者保存   |
  | `%r11` | `%r11d` | `%r11w` | `%r11b` | 调用者保存   |
  | `%r12` | `%r12d` | `%r12w` | `%r12b` | 被调用者保存 |
  | `%r13` | `%r13d` | `%r13w` | `%r13b` | 被调用者保存 |
  | `%r14` | `%r14d` | `%r14w` | `%r14b` | 被调用者保存 |
  | `%r15` | `%r15d` | `%r15w` | `%r15b` | 被调用者保存 |

  > 生成1字节和2字节数字的指令会保持剩下的字节不变；生成4字节数字的指令会把高位4字节置0。
  
* 操作数格式

  | 类型   | 格式             | 操作数值                 | 名称              |
  | ------ | ---------------- | ------------------------ | ----------------- |
  | 立即数 | $\$Imm$          | $Imm$                    | 立即数寻址        |
  | 寄存器 | $r_a$            | $R[r_a]$                 | 寄存器寻址        |
  | 存储器 | $Imm$            | $M[Imm]$                 | 绝对寻址          |
  | 存储器 | $(r_a)$          | $M[R[r_a]]$              | 间接寻址          |
  | 存储器 | $Imm(r_b)$       | $M[Imm+R[r_b]]$          | (基址+偏移量)寻址 |
  | 存储器 | $(r_b,r_i)$      | $M[R[r_b]+R[r_i]]$       | 变址寻址          |
  | 存储器 | $Imm(r_b,r_i)$   | $M[Imm+R[r_b]+R[r_i]]$   | 变址寻址          |
  | 存储器 | $(,r_i,s)$       | $M[R[r_i]*s]$            | 比例变址寻址      |
  | 存储器 | $Imm(,r_i,s)$    | $M[Imm+R[r_i]*s]$        | 比例变址寻址      |
  | 存储器 | $(r_b,r_i,s)$    | $M[R[r_b]+R[r_i]*s]$     | 比例变址寻址      |
  | 存储器 | $Imm(r_b,r_i,s)$ | $M[Imm+R[r_b]+R[r_i]*s]$ | 比例变址寻址      |

  * 立即数：$后跟一个用标准C表示的整数，不同指令允许的立即数范围不同。
  
  * 寄存器：$r_a$表示任意寄存器，用$R[r_a]$表示它的值。
  * 内存引用：$M_b[Addr]$表示内存中从$Addr$开始的b个字节的引用，通常省去下标b。
  * 基址寄存器$r_b$和变址寄存器$r_i$都必须是64位寄存器，s必须是1、2、4或者8。
  
* 数据传送指令

  | 指令(类)          | 效果                                                        | 描述           | 具体指令                                                   | 源操作数             | 目的操作数   |
  | ----------------- | ----------------------------------------------------------- | -------------- | ---------------------------------------------------------- | -------------------- | ------------ |
  | $MOV\quad S,\ D$  | $D\leftarrow S$                                             | 传送           | `movb`、`movw`、`movl`、`movq`、`movabsq`                  | 立即数、寄存器、内存 | 寄存器、内存 |
  | $MOVZ\quad S,\ R$ | $R\leftarrow 零扩展(S)$                                     | 以零扩展传送   | `movzbw`、`movzbl`、`movzwl`、`movzbq`、`movzwq`           | 寄存器、内存         | 寄存器       |
  | $MOVS\quad S,\ R$ | $R\leftarrow 符号扩展(S)$                                   | 以符号扩展传送 | `movsbw`、`movsbl`、`movswl`、`movsbq`、`movswq`、`movslq` | 寄存器、内存         | 寄存器       |
  | $cltq$            | $\%rax\leftarrow  符号扩展(\%eax)$                          | 以符号扩展传送 | 指令                                                       | 寄存器`%eax`         | 寄存器`%rax` |
  | $pushq\quad S$    | $R[\%rsp]\leftarrow R[\%rsp] - 8$ $M[R[\%rsp]]\leftarrow S$ | 将四字压栈     | 指令                                                       |                      |              |
  | $popq\quad D$     | $D\leftarrow M[R[\%rsp]]$ $R[\%rsp]\leftarrow R[\%rsp] + 8$ | 将四字弹出栈   | 指令                                                       |                      |              |

  * MOV类指令不能内存到内存传送。
  * `movl`指令以寄存器为目的时，会把目的寄存器高4字节置0，参见“整数寄存器”描述。因此没有`movzlq`指令。
  * 源操作数为立即数时，`movq`要求其必须能表示为32位补码，然后将之符号扩展到64位后传送。`movabsq`指令能够以任意64位立即数作为源操作数，并且只能以寄存器作为目的。

* 算术逻辑操作指令

  | 指令(类)          | 效果                                                         | 描述         |
  | ----------------- | ------------------------------------------------------------ | ------------ |
  | $leaq\quad S,\ D$ | $D\leftarrow \&S$                                            | 加载有效地址 |
  | $INC\quad D$      | $D\leftarrow D+1$                                            | 加1          |
  | $DEC\quad D$      | $D\leftarrow D-1$                                            | 减1          |
  | $NEG\quad D$      | $D\leftarrow -D$                                             | 取负         |
  | $NOT\quad D$      | $D\leftarrow\sim D$                                          | 取补         |
  | $ADD\quad S,\ D$  | $D\leftarrow D+S$                                            | 加           |
  | $SUB\quad S,\ D$  | $D\leftarrow D-S$                                            | 减           |
  | $IMUL\quad S,\ D$ | $D\leftarrow D*S$                                            | 乘           |
  | $XOR\quad S,\ D$  | $D\leftarrow D\verb!^! S$                                    | 异或         |
  | $OR\quad S,\ D$   | $D\leftarrow D|S$                                            | 或           |
  | $AND\quad S,\ D$  | $D\leftarrow D\&S$                                           | 与           |
  | $SAL\quad k,\ D$  | $D\leftarrow D<<k$                                           | 左移         |
  | $SHL\quad k,\ D$  | $D\leftarrow D<<k$                                           | 左移(同SAL)  |
  | $SAR\quad k,\ D$  | $D\leftarrow D>>_Ak$                                         | 算术右移     |
  | $SHR\quad k,\ D$  | $D\leftarrow D>>_Lk$                                         | 逻辑右移     |
  | $imulq\quad S$    | $R[\%rdx]:R[\%rax]\leftarrow S*R[\%rax]$                     | 有符号全乘法 |
  | $mulq\quad S$     | $R[\%rdx]:R[\%rax]\leftarrow S*R[\%rax]$                     | 无符号全乘法 |
  | $cqto$            | $R[\%rdx]:R[\%rax]\leftarrow 符号扩展(R[\%rax])$             | 转换为八字   |
  | $idivq\quad S$    | $R[\%rdx]\leftarrow R[\%rdx]:R[\%rax]\ mod\ S$ <br>$R[\%rdx]\leftarrow R[\%rdx]:R[\%rax]\div S$ | 有符号除法   |
  | $divq\quad S$     | $R[\%rdx]\leftarrow R[\%rdx]:R[\%rax]\ mod\ S$ <br/>$R[\%rdx]\leftarrow R[\%rdx]:R[\%rax]\div S$ | 无符号除法   |
  
  * 大写是指令类，包含四种不同大小数据的变种，例如ADD由四条指令组成`addb`、`addw`、`addl`、`addq`。小写是具体指令，没有变种。
  * `leaq`指令将有效地址写入目的寄存器。
  * 一元操作的操作数既可以是内存也可以是寄存器，二元操作的第一个操作数可以是立即数、寄存器或内存，第二个操作是寄存器或者内存。
  * 移位操作`k`可以是立即数或者寄存器`%cl`，第二个操作数可以是寄存器或者内存位置。
  * `imulq`有两种形式，一种属于`IMUL`指令类，双操作数，提供$64位*64位\rightarrow64位$的整数乘法。另一种属于上面单列的`imulq`指令，单操作数，提供$64位*64位\rightarrow128位$的整数乘法。因为乘积截断时，无符号乘和补码乘的位级表示一致，所以`IMUL`的`imulq`指令只有一条，而没有`mulq`。
  * Intel文档中`cqto`叫做`cqo`。
  
* 条件码寄存器

  | 条件码 | 含义                                                 |
  | ------ | ---------------------------------------------------- |
  | `CF`   | 进位标志，最近的操作产生进位，可检查无符号操作溢出。 |
  | `ZF`   | 零标志，最近操作结果为0。                            |
  | `SF`   | 符号标志，最近操作结果为负。                         |
  | `OF`   | 溢出标志，最近操作导致补码溢出(正溢出、负溢出)。     |

* 条件码相关指令

  | 指令类               | 基于        | 包含                               | 描述 |
  | -------------------- | ----------- | ---------------------------------- | ---- |
  | $CMP\quad S_1\ S_2$  | $S_2 - S_1$ | `cmpb`、`cmpw`、`cmpl`、`cmpq`     | 比较 |
  | $TEST\quad S_1\ S_2$ | $S_1\&S_2$  | `testb`、`testw`、`testl`、`testq` | 测试 |

  * 以上两个指令类只设置条件码不改变任何其它寄存器。

  | 指令           | 同义名   | 效果                                       | 设置条件             |
  | -------------- | -------- | ------------------------------------------ | -------------------- |
  | $sete\quad D$  | $setz$   | $D\leftarrow ZF$                           | 相等/零              |
  | $setne\quad D$ | $setnz$  | $D\leftarrow \sim ZF$                      | 不等/非零            |
  | $sets\quad D$  |          | $D\leftarrow SF$                           | 负数                 |
  | $setns\quad D$ |          | $D\leftarrow \sim SF$                      | 非负数               |
  | $setg\quad D$  | $setnle$ | $D\leftarrow \sim(SF\verb!^! OF)\&\sim ZF$ | 大于(有符号>)        |
  | $setge\quad D$ | $setnl$  | $D\leftarrow \sim(SF\verb!^! OF)$          | 大于等于(有符号>=)   |
  | $setl\quad D$  | $setnge$ | $D\leftarrow SF\verb!^! OF$                | 小于(有符号)         |
  | $setle\quad D$ | $setng$  | $D\leftarrow (SF\verb!^! OF)|ZF$           | 小于等于(有符号<=)   |
  | $seta\quad D$  | $setnbe$ | $D\leftarrow \sim CF\&\sim ZF$             | 超过(无符号>)        |
  | $setae\quad D$ | $setnb$  | $D\leftarrow \sim CF$                      | 超过或相等(无法>=)   |
  | $setb\quad D$  | $setnae$ | $D\leftarrow CF$                           | 低于(无符号<)        |
  | $setbe\quad D$ | $setna$  | $D\leftarrow CF|ZF$                        | 低于或相等(无符号<=) |

  * 以上指令的后缀表示不同的条件而不是操作数的大小。
  * 目的操作数是低位单字节寄存器之一或者一个字节的内存位置。
  * 同义名就是同一条机器指令的不同名字。
  
* 跳转指令

  | 指令                | 同义名 | 跳转条件                       | 描述                 |
  | ------------------- | ------ | ------------------------------ | -------------------- |
  | $jmp\quad Label$    |        | $1$                            | 直接跳转             |
  | $jmp\quad *Operand$ |        | $1$                            | 间接跳转             |
  | $je\quad Label$     | $jz$   | $ZF$                           | 相等/零              |
  | $jne\quad Label$    | $jnz$  | $\sim ZF$                      | 不相等/非零          |
  | $js\quad Lable$     |        | $SF$                           | 负数                 |
  | $jns\quad Label$    |        | $\sim SF$                      | 非负数               |
  | $jg\quad Label$     | $jnle$ | $\sim(SF\verb!^! OF)\&\sim ZF$ | 大于(有符号>)        |
  | $jge\quad Label$    | $jnl$  | $\sim(SF\verb!^! OF)$          | 大于或等于(有符号>=) |
  | $jl\quad Label$     | $jnge$ | $SF\verb!^! OF$                | 小于(有符号<)        |
  | $jle\quad Label$    | $jng$  | $(SF\verb!^! OF)|ZF$           | 小于或等于(有符号<=) |
  | $ja\quad Label$     | $jnbe$ | $\sim CF\&\sim ZF$             | 超过(无符号>)        |
  | $jae\quad Label$    | $jnb$  | $\sim CF$                      | 超过或相等(无符号>=) |
  | $jb\quad Label$     | $jnae$ | $CF$                           | 低于(无符号<)        |
  | $jbe\quad Label$    | $jna$  | $CF|ZF$                        | 低于或相等(无符号<=) |

  * 前两条是无条件跳转，其中间接跳转的目标可以是从寄存器或内存位置中读出。其余的都是有条件跳转，只能是直接跳转。
  * 跳转指令常用的编码有：PC相对地址(会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码)、绝对地址(用4字节直接指定目标)。

* 条件传送指令

  | 指令                | 同义名    | 传送条件                       | 描述                 |
  | ------------------- | --------- | ------------------------------ | -------------------- |
  | $cmove\quad S,\ R$  | $cmovz$   | $ZF$                           | 相等/零              |
  | $cmovne\quad S,\ R$ | $cmovnz$  | $\sim ZF$                      | 不相等/非零          |
  | $cmovs\quad S,\ R$  |           | $SF$                           | 负数                 |
  | $cmovns\quad S,\ R$ |           | $\sim SF$                      | 非负数               |
  | $cmovg\quad S,\ R$  | $cmovnle$ | $\sim(SF\verb!^! OF)\&\sim ZF$ | 大于(有符号>)        |
  | $cmovge\quad S,\ R$ | $cmovnl$  | $\sim(SF\verb!^! OF)$          | 大于或等于(有符号>=) |
  | $cmovl\quad S,\ R$  | $cmovnge$ | $SF\verb!^! OF$                | 小于(有符号<)        |
  | $cmovle\quad S,\ R$ | $cmovng$  | $(SF\verb!^! OF)|ZF$                           | 小于或等于(有符号<=) |
  | $cmova\quad S,\ R$  | $cmovnbe$ | $\sim CF\&\sim ZF$                           | 超过(无符号>)        |
  | $cmovae\quad S,\ R$ | $cmovnb$  | $\sim CF$                           | 超过或相等(无符号>=) |
  | $cmovb\quad S,\ R$  | $cmovnae$ | $CF$                           | 低于(无符号<)        |
  | $cmovbe\quad S,\ R$ | $cmovna$  | $CF|ZF$                           | 低于或相等(无符号<=) |

  * 条件传送指令：当传送条件满足时，指令把源值S复制到目的R。源操作数可以是寄存器或内存地址，目的操作数是寄存器。源和目的的值可以是16位、32位和64位。汇编器可以从目的寄存器名字推断出条件传送指令的操作数长度，所以对不同长度的操作数都可以用同一个指令名字。
  * 条件操作语句可以用两种策略实现，一种是条件控制转移，一种是条件数据传送。条件控制转移会根据条件切换执行路径，通用但可能低效，条件数据传送会计算条件操作的两种结果，根据条件选取一个，依靠处理器的分支预测逻辑可能会比较高效但不通用。
  
* 控制转移指令

  | 指令                 | 描述             |
  | -------------------- | ---------------- |
  | $call\quad Label$    | 过程调用         |
  | $call\quad *Operand$ | 过程调用         |
  | $ret$                | 从过程调用中返回 |

  * `call Q`会将返回地址(紧跟在`call`指令后的那条指令的地址)压入栈中，并将PC设置为过程Q的起始地址。
  * `ret`指令会从栈中弹出返回地址，并把PC设置为返回地址。
  * 在`OBJDUMP`产生的反汇编输出中，上述指令会被称为`callq`和`retq`，后缀`q`只是强调指令是`x86-64`版本，而非`IA32`。
  * 在跳转指令和`ret`指令间，一般使用`rep`指令作为空操作。因为`ret`指令通过跳转指令到达时，处理器不能预测`ret`指令的目的。
  
* 浮点代码

  * `x86-64`浮点数是基于`SSE`或`AVX`的，包括传递过程参数和返回值的规则，这些指令的本意是允许多个操作以并行模式执行，称为单指令多数据或`SIMD`。以下描述基于`AVX2`：

  * 媒体寄存器

    | 255~0    | 127~0    | 用途                |
    | -------- | -------- | ------------------- |
    | `%ymm0`  | `%xmm0`  | `1st FP arg.返回值` |
    | `%ymm1`  | `%xmm1`  | `2nd FP 参数`       |
    | `%ymm2`  | `%xmm2`  | `3rd FP 参数`       |
    | `%ymm3`  | `%xmm3`  | `4th FP 参数`       |
    | `%ymm4`  | `%xmm4`  | `5th FP 参数`       |
    | `%ymm5`  | `%xmm5`  | `6th FP 参数`       |
    | `%ymm6`  | `%xmm6`  | `7th FP 参数`       |
    | `%ymm7`  | `%xmm7`  | `8th FP 参数`       |
    | `%ymm8`  | `%xmm8`  | `调用者保存`        |
    | `%ymm9`  | `%xmm9`  | `调用者保存`        |
    | `%ymm10` | `%xmm10` | `调用者保存`        |
    | `%ymm11` | `%xmm11` | `调用者保存`        |
    | `%ymm12` | `%xmm12` | `调用者保存`        |
    | `%ymm13` | `%xmm13` | `调用者保存`        |
    | `%ymm14` | `%xmm14` | `调用者保存`        |
    | `%ymm15` | `%xmm15` | `调用者保存`        |

  * 浮点传送指令
  
    | 指令      | 源       | 目的     | 描述         |
    | --------- | -------- | -------- | ------------ |
    | $vmovss$  | $M_{32}$ | $X$      | 传送单精度数 |
    | $vmovss$  | $X$      | $M_{32}$ | 传送单精度数 |
    | $vmovsd$  | $M_{64}$ | $X$      | 传送单精度数 |
    | $vmovsd$  | $X$      | $M_{64}$ | 传送单精度数 |
    | $vmovaps$ | $X$      | $X$      | 传送单精度数 |
    | $vmovapd$ | $X$      | $X$      | 传送单精度数 |
  
    * X表示XMM寄存器，M表示内存地址。
    
  * 双操作数浮点转换指令
  
    | 指令          | 源         | 目的     | 描述                                 |
    | ------------- | ---------- | -------- | ------------------------------------ |
    | $vcvttss2si$  | $X/M_{32}$ | $R_{32}$ | 用截断的方法把单精度数转换成整数     |
    | $vcvttsd2si$  | $X/M_{64}$ | $R_{32}$ | 用截断的方法把双精度数转换成整数     |
    | $vcvttss2siq$ | $X/M_{32}$ | $R_{64}$ | 用截断的方法把单精度数转换成四字整数 |
    | $vcvttsd2siq$ | $X/M_{64}$ | $R_{64}$ | 用截断的方法把双精度数转换成四字整数 |
  
    * R表示通用寄存器。
  
  * 三操作数浮点转换指令
  
    | 指令         | 源1             | 源2  | 目的 | 描述                     |
    | ------------ | --------------- | ---- | ---- | ------------------------ |
    | $vcvtsi2ss$  | $M_{32}/R_{32}$ | X    | X    | 把整数转换成单精度数     |
    | $vcvtsi2sd$  | $M_{32}/R_{32}$ | X    | X    | 把整数转换成双精度数     |
    | $vcvtsi2ssq$ | $M_{64}/R_{64}$ | X    | X    | 把四字整数转换成单精度数 |
    | $vcvtsi2sdq$ | $M_{64}/R_{64}$ | X    | X    | 把四字整数转换成双精度数 |
  
    * 在这里可以忽略第二个操作数，因为它的值只会影响结果的高位字节。
    
  * 标量浮点算术运算
  
    | 单精度   | 双精度   | 效果                       | 描述         |
    | -------- | -------- | -------------------------- | ------------ |
    | $vaddss$ | $vaddsd$ | $D\leftarrow S_2+S_1$      | 浮点数加     |
    | $vsubss$ | $vsubsd$ | $D\leftarrow S_2-S_1$      | 浮点数减     |
    | $vmulss$ | $vmulsd$ | $D\leftarrow S_2*S_1$      | 浮点数乘     |
    | $vdivss$ | $vdivsd$ | $D\leftarrow S_2/S_1$      | 浮点数除     |
    | $vmaxss$ | $vmaxsd$ | $D\leftarrow max(S_2+S_1)$ | 浮点数最大值 |
    | $vminss$ | $vminsd$ | $D\leftarrow min(S_2+S_1)$ | 浮点数最小值 |
    | $sqrtss$ | $sqrtsd$ | $D\leftarrow \sqrt S_1$    | 浮点数平方根 |
  
    * 第一个源操作数是XMM寄存器或者内存，第二个源操作数和目的操作数是XMM寄存器。
  
  * 浮点位级操作
  
    | 单精度   | 双精度  | 效果                          | 描述                   |
    | -------- | ------- | ----------------------------- | ---------------------- |
    | $vxorps$ | $xorpd$ | $D\leftarrow S_2\verb!^! S_1$ | 位级异或(EXCLUSIVE-OR) |
    | $vandps$ | $andpd$ | $D\leftarrow S_2\&S_1$        | 位级与(AND)            |
  
  * 浮点比较操作
  
    | 指令                      | 基于      | 描述         |
    | ------------------------- | --------- | ------------ |
    | $vucomiss\quad S_1,\ S_2$ | $S_2-S_1$ | 比较单精度值 |
    | $vucomisd\quad S_1,\ S_2$ | $S_2-S_1$ | 比较双精度值 |
  
    * 这些指令类似CMP指令。第一个操作数可以是XMM寄存器或内存，第二个操作数是XMM寄存器。
